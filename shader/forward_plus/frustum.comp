/**
 * 预计算 frustum
 * frustum 的平面朝向内部
 * 平面参数是 view space 中的参数
 */
#version 450
#extension GL_GOOGLE_include_directive : enable
#include "type.glsl"
#include "../shader/common.glsl"


layout(constant_id = 3) const uint TILE_NUM_X = 2u;
layout(constant_id = 4) const uint TILE_NUM_Y = 2u;

layout(local_size_x_id = 5, local_size_y_id = 6, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) buffer ssbo
{
    Frustum Frustums[];
};
layout(std140, set = 0, binding = 1) uniform _1
{
    Scene u_scene;
};


/**
 * 根据三个顶点得到平面的参数
 * 平面方向由右手确定
 */
Plane compute_plane(vec3 p0, vec3 p1, vec3 p2)
{
    Plane plane;

    vec3 v1 = p1 - p0;
    vec3 v2 = p2 - p0;
    plane.N = normalize(cross(v1, v2));

    plane.d = dot(plane.N, p0);

    return plane;
}


// 每个 thread 负责一个 tile
void main()
{
    // view space 中 eye 的坐标
    vec3 eye_pos = vec3(0);


    /**
     * frag 坐标遵循 glsl 的规则
     * xy 是屏幕坐标系的坐标，范围是 [0, 1] * [0, 1]
     * z  是深度值，这里选择远平面（近平面也可以），因此 z = 1.0
     * w  是 1/clip_w，是一个正数，也就是 1/far
     */
    const float frag_w = 1.0 / u_scene.far;


    // screen space 中 tile 的 4 个 corner 的坐标
    // 每个 thread 对应一个 tile
    //   0 ----- 1---> x
    //   |       |
    //   |       |
    //   2 ----- 3
    //   v y
    vec4 tile_corners_screen[4];
    tile_corners_screen[0] = vec4(gl_GlobalInvocationID.xy * TILE_SIZE, 1, frag_w);
    tile_corners_screen[1] = vec4((gl_GlobalInvocationID.xy + vec2(1, 0)) * TILE_SIZE, 1, frag_w);
    tile_corners_screen[2] = vec4((gl_GlobalInvocationID.xy + vec2(0, 1)) * TILE_SIZE, 1, frag_w);
    tile_corners_screen[3] = vec4((gl_GlobalInvocationID.xy + vec2(1, 1)) * TILE_SIZE, 1, frag_w);

    // 从 screen 转换为 view space
    vec3 tile_corners_view[4];
    for (int i = 0; i < 4; ++i)
    {
        tile_corners_view[i] = screen_to_view(tile_corners_screen[i], vec2(u_scene.screen_width, u_scene.screen_height),
                                              u_scene.in_proj_matrix)
                                       .xyz;
    }


    // 得到 frustum 的平面
    Frustum frustum;
    frustum.left   = compute_plane(eye_pos, tile_corners_view[2], tile_corners_view[0]);
    frustum.right  = compute_plane(eye_pos, tile_corners_view[1], tile_corners_view[3]);
    frustum.top    = compute_plane(eye_pos, tile_corners_view[0], tile_corners_view[1]);
    frustum.bottom = compute_plane(eye_pos, tile_corners_view[3], tile_corners_view[2]);


    // 将平面的参数存放到 SSBO 中
    // 每个 thread 负责一个 tile
    if (gl_GlobalInvocationID.x < TILE_NUM_X && gl_GlobalInvocationID.y < TILE_NUM_Y)
    {
        uint index      = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * TILE_NUM_X;
        Frustums[index] = frustum;
    }
}