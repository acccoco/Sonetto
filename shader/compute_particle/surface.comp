#version 450
#define PI 3.14159265358979323846


struct Particle
{
    vec3 pos;
    float point_size;
    vec3 vel;
    float color_uv;
};


layout (push_constant) uniform _
{
    float time;
    uint kernel_id;
    float trans_progress;
};

layout (constant_id = 0) const uint DIM = 64;    // 每个方向上各有多少个粒子
layout (constant_id = 1) const float STEP = 0.1f;


// storage buffer
layout (std430, set = 0, binding = 0) buffer Data
{
    Particle particles[];
};

// workgroup 的尺寸
layout (local_size_x_id = 2, local_size_y_id = 3, local_size_z = 1) in;


// 根据 global id 得到 uv 坐标 [-1, 1] * [-1, 1]
vec2 get_uv(uvec3 global_id)
{
    return vec2(global_id.xy + 0.5) * STEP - 1.0;
}


// 将粒子的位置写入 storage buffer
void set_position(uvec3 global_id, vec3 position)
{
    if (global_id.x >= DIM || global_id.y >= DIM)
    return;

    // w 分量表示尺寸
    particles[global_id.x + global_id.y * DIM].pos = position;
    particles[global_id.x + global_id.y * DIM].point_size = 3.0;
}


// 正弦波的曲面方程
vec3 Wave(float u, float v)
{
    vec3 p;
    p.x = u;
    p.y = sin(PI * (u + v + time));
    p.z = v;
    return p;
}

vec3 MultiWave(float u, float v)
{
    vec3 p;
    p.x = u;
    p.y = sin(PI * (u + 0.5 * time));
    p.y += 0.5 * sin(2.0 * PI * (v + time));
    p.y += sin(PI * (u + v + 0.25 * time));
    p.y *= 1.0 / 2.5;
    p.z = v;
    return p;
}

vec3 Ripple(float u, float v)
{
    float d = sqrt(u * u + v * v);
    vec3 p;
    p.x = u;
    p.y = sin(PI * (4.0 * d - time));
    p.y /= 1.0 + 10.0 * d;
    p.z = v;
    return p;
}

vec3 Sphere(float u, float v)
{
    float r = 0.9 + 0.1 * sin(PI * (12.0 * u + 8.0 * v + time));
    float s = r * cos(0.5 * PI * v);
    vec3 p;
    p.x = s * sin(PI * u);
    p.y = r * sin(0.5 * PI * v);
    p.z = s * cos(PI * u);
    return p;
}

vec3 Torus(float u, float v)
{
    float r1 = 0.7 + 0.1 * sin(PI * (8.0 * u + 0.5 * time));
    float r2 = 0.15 + 0.05 * sin(PI * (16.0 * u + 8.0 * v + 3.0 * time));
    float s = r2 * cos(PI * v) + r1;
    vec3 p;
    p.x = s * sin(PI * u);
    p.y = r2 * sin(PI * v);
    p.z = s * cos(PI * u);
    return p;
}


/* 在两个形态之间转变的函数 */
vec3 trans(vec3 from, vec3 to)
{
    // smooth 就是 Hermite 插值
    return mix(from, to, smoothstep(0.0, 1.0, trans_progress));
}


void main()
{
    vec2 uv = get_uv(gl_GlobalInvocationID);
    vec3 position;
    switch (kernel_id)
    {
        case 0: position = Wave(uv.x, uv.y); break;
        case 1: position = trans(Wave(uv.x, uv.y), MultiWave(uv.x, uv.y)); break;

        case 2: position = MultiWave(uv.x, uv.y); break;
        case 3: position = trans(MultiWave(uv.x, uv.y), Sphere(uv.x, uv.y)); break;

        case 4: position = Sphere(uv.x, uv.y); break;
        case 5: position = trans(Sphere(uv.x, uv.y), Ripple(uv.x, uv.y)); break;

        case 6: position = Ripple(uv.x, uv.y); break;
        case 7: position = trans(Ripple(uv.x, uv.y), Torus(uv.x, uv.y)); break;

        case 8: position = Torus(uv.x, uv.y); break;
        case 9: position = trans(Torus(uv.x, uv.y), Wave(uv.x, uv.y)); break;
    }


    set_position(gl_GlobalInvocationID, position);
}